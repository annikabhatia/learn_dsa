# 🧠 Data Structures Implementation & Problem Set

This repository showcases a collection of classic data structure implementations and related problems to demonstrate understanding and mastery of fundamental and advanced data structures. Each category contains problems or implementations written in a clean, modular style.

---

## 📚 Table of Contents

- [Stack](#stack)
- [Queue](#queue)
- [Linked List](#linked-list)
- [Trees](#trees)
  - [Binary Tree](#binary-tree)
  - [Balanced Trees](#balanced-trees)
  - [N-ary Tree](#n-ary-tree)
- [Graphs](#graphs)
- [Hashing](#hashing)
- [Heap / Priority Queue](#heap--priority-queue)
- [Trie](#trie)
- [Bonus / Custom Structures](#bonus--custom-structures)

---

## 🥞 Stack

- **Valid Parentheses** – Check if parentheses are balanced using a stack.
- **Min Stack** – Design a stack that returns the minimum element in O(1) time.
- **Implement Stack Using Queues** – Simulate stack operations using queues.
- **Next Greater Element** – Find the next greater element for each array item.
- **Largest Rectangle in Histogram** – Use stack to find the largest rectangle in a histogram.

---

## 🔁 Queue

- **Implement Queue Using Stacks** – Use two stacks to implement a queue.
- **Circular Queue** – Fixed-size circular queue implementation.
- **Sliding Window Maximum** – Find max in each window using a deque.
- **Task Scheduler** – Schedule tasks with cooldown using a queue.
- **Design Hit Counter** – Count hits in past 5 minutes (real-time sliding window).

---

## 🔗 Linked List

- **Singly Linked List Implementation** – Build basic singly linked list.
- **Reverse Linked List** – Reverse a singly linked list.
- **Detect Cycle in Linked List** – Use Floyd’s algorithm to detect cycle.
- **Merge Two Sorted Lists** – Merge two sorted linked lists.
- **Remove N-th Node from End** – Efficiently remove nth node from the end.
- **Palindrome Linked List** – Check if a linked list is a palindrome.
- **Doubly Linked List Implementation** – Implement a DLL with add/remove operations.

---

## 🌳 Trees

### 🌲 Binary Tree

- **Binary Tree Inorder Traversal** – Traverse the tree in inorder.
- **Level Order Traversal** – BFS traversal by levels.
- **Lowest Common Ancestor** – Find the LCA of two nodes.
- **Check Balanced Tree** – Verify if tree is height-balanced.
- **Diameter of Binary Tree** – Compute the longest path in the tree.

### 🌳 Balanced Trees

- **AVL Tree Implementation** – Self-balancing tree with rotations.
- **Red-Black Tree Implementation** – Balanced BST with coloring rules.
- **Treap (Tree + Heap)** – Randomized BST for balancing on insert/delete.
- **Splay Tree** – Self-adjusting BST that brings recent nodes to root.

### 🌴 N-ary Tree

- **N-ary Tree Level Order Traversal** – Traverse children-level N-ary tree.
- **Serialize/Deserialize N-ary Tree** – Encode and decode the tree structure.
- **Maximum Depth of N-ary Tree** – Find the longest path from root to leaf.

---

## 🌐 Graphs

- **Graph Representation (Adjacency List/Matrix)** – Implement both forms.
- **DFS and BFS Traversal** – Depth- and breadth-first graph traversals.
- **Cycle Detection (Directed/Undirected)** – Detect cycles using DFS/Union-Find.
- **Topological Sort** – Order of tasks using Kahn’s algorithm or DFS.
- **Dijkstra’s Algorithm** – Shortest path using a priority queue.
- **Bellman-Ford Algorithm** – Handle graphs with negative weights.
- **A* Search Algorithm** – Heuristic-based shortest path algorithm.
- **Clone Graph** – Create a deep copy of a connected graph.

---

## 🔢 Hashing

- **Two Sum** – Find indices of two numbers that add to target.
- **Group Anagrams** – Group words that are anagrams.
- **First Unique Character** – Find first non-repeating character in a string.
- **Subarray Sum Equals K** – Count subarrays that sum to a target.
- **Longest Consecutive Sequence** – Use hash set to track sequence.

---

## 🛠️ Heap / Priority Queue

- **Kth Largest Element** – Find the k-th largest element using a heap.
- **Merge K Sorted Lists** – Merge using a min-heap.
- **Top K Frequent Elements** – Find most frequent elements.
- **Median from Data Stream** – Maintain a running median with two heaps.
- **Reorganize String** – Rearrange characters to avoid adjacent duplicates.

---

## 🔤 Trie

- **Implement Trie (Prefix Tree)** – Insert, search, and startsWith functions.
- **Word Search II** – Use Trie + DFS to search for multiple words in a board.
- **Longest Word in Dictionary** – Find longest word that can be built one letter at a time.
- **Auto-complete System** – Implement a predictive search engine.

---

## 🧪 Bonus / Custom Structures

- **Custom HashMap/HashSet** – Build hash table from scratch.
- **LRU Cache** – Use doubly linked list + hash map for caching.
- **LFU Cache** – Least Frequently Used cache system.
- **Skip List** – Efficient probabilistic list structure for O(log n) operations.
- **Bloom Filter** – Space-efficient probabilistic structure for set membership.

---

## 🧰 Languages & Tools

These problems will be implemented in different languages to showcase versatility:
- Python 🐍
- Java ☕
- JavaScript ⚡

Each folder will contain:
- Source Code
- README.md file containting the problem
- Unit Tests (where applicable)

---

## 📌 Implementation Roadmap

✅ = Done  
🚧 = In Progress  
📝 = Planned

---



