# ğŸ§  Data Structures Implementation & Problem Set

This repository showcases a collection of classic data structure implementations and related problems to demonstrate understanding and mastery of fundamental and advanced data structures. Each category contains problems or implementations written in a clean, modular style.

---

## ğŸ“š Table of Contents

- [Stack](#stack)
- [Queue](#queue)
- [Linked List](#linked-list)
- [Trees](#trees)
  - [Binary Tree](#binary-tree)
  - [Balanced Trees](#balanced-trees)
  - [N-ary Tree](#n-ary-tree)
- [Graphs](#graphs)
- [Hashing](#hashing)
- [Heap / Priority Queue](#heap--priority-queue)
- [Trie](#trie)
- [Bonus / Custom Structures](#bonus--custom-structures)

---

## ğŸ¥ Stack

- **Valid Parentheses** â€“ Check if parentheses are balanced using a stack.
- **Min Stack** â€“ Design a stack that returns the minimum element in O(1) time.
- **Implement Stack Using Queues** â€“ Simulate stack operations using queues.
- **Next Greater Element** â€“ Find the next greater element for each array item.
- **Largest Rectangle in Histogram** â€“ Use stack to find the largest rectangle in a histogram.

---

## ğŸ” Queue

- **Implement Queue Using Stacks** â€“ Use two stacks to implement a queue.
- **Circular Queue** â€“ Fixed-size circular queue implementation.
- **Sliding Window Maximum** â€“ Find max in each window using a deque.
- **Task Scheduler** â€“ Schedule tasks with cooldown using a queue.
- **Design Hit Counter** â€“ Count hits in past 5 minutes (real-time sliding window).

---

## ğŸ”— Linked List

- **Singly Linked List Implementation** â€“ Build basic singly linked list.
- **Reverse Linked List** â€“ Reverse a singly linked list.
- **Detect Cycle in Linked List** â€“ Use Floydâ€™s algorithm to detect cycle.
- **Merge Two Sorted Lists** â€“ Merge two sorted linked lists.
- **Remove N-th Node from End** â€“ Efficiently remove nth node from the end.
- **Palindrome Linked List** â€“ Check if a linked list is a palindrome.
- **Doubly Linked List Implementation** â€“ Implement a DLL with add/remove operations.

---

## ğŸŒ³ Trees

### ğŸŒ² Binary Tree

- **Binary Tree Inorder Traversal** â€“ Traverse the tree in inorder.
- **Level Order Traversal** â€“ BFS traversal by levels.
- **Lowest Common Ancestor** â€“ Find the LCA of two nodes.
- **Check Balanced Tree** â€“ Verify if tree is height-balanced.
- **Diameter of Binary Tree** â€“ Compute the longest path in the tree.

### ğŸŒ³ Balanced Trees

- **AVL Tree Implementation** â€“ Self-balancing tree with rotations.
- **Red-Black Tree Implementation** â€“ Balanced BST with coloring rules.
- **Treap (Tree + Heap)** â€“ Randomized BST for balancing on insert/delete.
- **Splay Tree** â€“ Self-adjusting BST that brings recent nodes to root.

### ğŸŒ´ N-ary Tree

- **N-ary Tree Level Order Traversal** â€“ Traverse children-level N-ary tree.
- **Serialize/Deserialize N-ary Tree** â€“ Encode and decode the tree structure.
- **Maximum Depth of N-ary Tree** â€“ Find the longest path from root to leaf.

---

## ğŸŒ Graphs

- **Graph Representation (Adjacency List/Matrix)** â€“ Implement both forms.
- **DFS and BFS Traversal** â€“ Depth- and breadth-first graph traversals.
- **Cycle Detection (Directed/Undirected)** â€“ Detect cycles using DFS/Union-Find.
- **Topological Sort** â€“ Order of tasks using Kahnâ€™s algorithm or DFS.
- **Dijkstraâ€™s Algorithm** â€“ Shortest path using a priority queue.
- **Bellman-Ford Algorithm** â€“ Handle graphs with negative weights.
- **A* Search Algorithm** â€“ Heuristic-based shortest path algorithm.
- **Clone Graph** â€“ Create a deep copy of a connected graph.

---

## ğŸ”¢ Hashing

- **Two Sum** â€“ Find indices of two numbers that add to target.
- **Group Anagrams** â€“ Group words that are anagrams.
- **First Unique Character** â€“ Find first non-repeating character in a string.
- **Subarray Sum Equals K** â€“ Count subarrays that sum to a target.
- **Longest Consecutive Sequence** â€“ Use hash set to track sequence.

---

## ğŸ› ï¸ Heap / Priority Queue

- **Kth Largest Element** â€“ Find the k-th largest element using a heap.
- **Merge K Sorted Lists** â€“ Merge using a min-heap.
- **Top K Frequent Elements** â€“ Find most frequent elements.
- **Median from Data Stream** â€“ Maintain a running median with two heaps.
- **Reorganize String** â€“ Rearrange characters to avoid adjacent duplicates.

---

## ğŸ”¤ Trie

- **Implement Trie (Prefix Tree)** â€“ Insert, search, and startsWith functions.
- **Word Search II** â€“ Use Trie + DFS to search for multiple words in a board.
- **Longest Word in Dictionary** â€“ Find longest word that can be built one letter at a time.
- **Auto-complete System** â€“ Implement a predictive search engine.

---

## ğŸ§ª Bonus / Custom Structures

- **Custom HashMap/HashSet** â€“ Build hash table from scratch.
- **LRU Cache** â€“ Use doubly linked list + hash map for caching.
- **LFU Cache** â€“ Least Frequently Used cache system.
- **Skip List** â€“ Efficient probabilistic list structure for O(log n) operations.
- **Bloom Filter** â€“ Space-efficient probabilistic structure for set membership.

---

## ğŸ§° Languages & Tools

These problems will be implemented in different languages to showcase versatility:
- Python ğŸ
- Java â˜•
- JavaScript âš¡

Each folder will contain:
- Source Code
- README.md file containting the problem
- Unit Tests (where applicable)

---

## ğŸ“Œ Implementation Roadmap

âœ… = Done  
ğŸš§ = In Progress  
ğŸ“ = Planned

---



